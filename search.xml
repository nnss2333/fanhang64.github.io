<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[排序总结]]></title>
    <url>%2F2021%2F01%2F07%2F%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[稳定性：如果存在重复关键字，原则排序算法时，要考虑稳定性。例如：50(a)在50(b)之前，排完序后扔在之前，说明稳定 插入类排序1) 直接插入 将待排序记录，插入到已排好的有序序列中，重复n-1次 代码12345678910111213void insertSort(int a[], int n)&#123; // 带排序数组在a，元素个数为n，从下标1开始存储 int i,j; for(i=2;i&lt;=n;i++)&#123; if(a[i] &lt; a[i-1])&#123; // 如果是为正序，这里不执行。 a[0] = a[i]; // a[0]为哨兵 for(j=i-1;a[0]&lt;a[j];--j)&#123; a[j+1] = a[j]; &#125; a[j+1] = a[0]; // 找到插入位置，将暂存关键字插入 &#125; &#125; &#125; 例题 分析 1) 最坏情况，整个序列逆序的，此时时间复杂度为O(n^2)2) 最好的情况，整个序列已经有序，内层循环不执行，则时间复杂度为O(n)。3) 空间复杂度为O(1)4) 一趟排序后，不能确定一个关键字到达最后位置。插入类排序共同特点5) 一种稳定排序算法6) 直接插入最坏情况下，比较次数为n(n-1)/2，最好情况下为n-1 2) 折半插入 折半插入排序，通过折半查找法确定插入位置。 基本条件：序列已经有序。 例题 代码 12345678910111213141516171819void InsertSort(int a[],int n)&#123; int i,j,low,high,mid; for(i=2;i&lt;=n;i++)&#123; // 将a[2]至a[n]插入到前面已经排好序的序列 a[0]=a[i]; low = 1; high= i-1; while(low &lt;= high)&#123; mid = (low+high) / 2; if(a[mid] &gt; a[0])&#123; high = mid -1; &#125;else&#123; low =mid+1; &#125; &#125; for(j=i-1;j&gt;=high+1;--j)&#123; a[j+1] = a[j]; &#125; a[j+1] = a[0]; &#125;&#125; 性能分析 1) 平均时间复杂度O(n^2)2) 稳定的插入排序3) 关键字比较次数与初始序列无关。4) 只是比直接插入少了比较次数，约为O(nlogn) 3) 希尔排序 先将待排序序列分割成若干个子序列，分别进行直接插入排序，基本有序后，在整体进行直接插入排序。 步骤： 1231) 按照增量d，将序列分成几个子序列。2) 对子序列排序(直接插入排序)3) 缩小增量d，重复1，2步，直到增量d=1 代码 12345678910111213# 希尔排序void shellInsert(sqList &amp;L, int dk)&#123; // L顺序表，dk为增量 for(i = dk+1;i≤L.length;++i)&#123; if(L.r[i].key&lt;L.r[i-dk].key)&#123; // L.r[0] = L.r[i]; // 暂存到L.r[0] for(j=i-dk; j&gt;0 &amp;&amp; (L.r[0].key &lt; L.r[j].key); j-=dk)&#123; // 记录后移，寻找插入位置 L.r[j+dk] = L.r[j]; &#125; L.r[j+dk] = L.r[0]; // 插入到指定位置 &#125; &#125; &#125; 例题 性能分析 1) 希尔排序增量最后一定为12) 希尔排序为不稳定排序。3) 时间复杂度大约为O(n^1.5)4) 空间复杂度为O(1)5) 按增量分组，组内采用直接插入排序。 交换类排序1) 冒泡排序 依次比较相邻元素，逆序则交换，n个元素重复n-1次。 冒泡排序一趟确定一个元素的最终位置(可能会多次交换)。 代码 12345678910111213141516void bubblesorSort(int a[], int n)&#123; // 数组元素下标从0-n-1 for(i=n-1; i&gt;=1;i--)&#123; // n个关键字最多要n-1趟 flag = 0; for(j=1;j&lt;=i;j++)&#123; if(a[j-1]&gt;a[j])&#123; temp = a[j-1]; a[j-1] = a[j]; a[j] = temp; flag = 1; // 如果没发生交换，则flag为0，发生交换值为1 &#125; &#125; if(flag == 0)&#123; // 如果一趟排序，没有发生关键字交换，则证明有序，排序结束。 return; &#125; &#125;&#125; 性能分析 1) n个关键字，需要n-1趟2) 时间复杂度最坏情况，为逆序序列，时间复杂度为O(n^2)3) 最好情况，序列有序，内层循环if始终不成立，flag为0，内层循环执行n-1次比较，执行结束。4) 空间复杂度为O(1)5) 每一趟都会确定一个元素在最终位置上。6) 24个关键字，冒泡排序最少比较次数23次(本代码中的第1趟)。 2) 快速排序 每一趟选择当前所有子序列的一个关键字(通常第一个)作为枢轴，将子序列中比枢轴小的移到枢轴前，比枢轴大的元素，移动到枢轴后。 例题 代码 1234567891011121314151617void QuickSort(int a[], int low, int high)&#123; int pivot; int i = low; int j = high; if(low &lt; high)&#123; pivot = a[low]; while(i&lt;j)&#123; while(i&lt;j &amp;&amp; a[j] &gt;= pivot) j--; // 找小于pivot的位置 a[i] = a[j]; while(i&lt;j &amp;&amp; a[i] &lt;= pivot) i++; a[j] = a[i]; &#125; a[i] = pivot; QuickSort(a, low, i-1); QuickSort(a, i+1, high); &#125;&#125; 性能分析 1) 平均时间复杂度O(nlogn)，最坏情况时间复杂度为O(n^2)2) 平均空间复杂度为O(logn)，递归进行，需要用到栈，最坏情况下为O(n)。3) 待排序列越接近无序，算法效率越好；若序列基本有序，则退化为冒泡排序。4) 快速排序是不稳定的排序算法。5) 当每次的枢轴把表等分为两个长度相近的子表时候，速度最快。例如：第一趟，枢轴值21将表划分为两个子表{9，17，5}和{25，23，30}6) 快排每趟可以有一个元素处于最终位置 上。(枢轴处于最终位置)7) 如果第一趟执行完(8，9，4，3，6，1)，10，(12，18，18)，第二趟执行结束为(1，6，4，3)，8，(9)，10，12，(18，18)，两个子序列同时排序，算第二趟。 选择类排序1) 简单选择排序 在待排序列中，选取最小的，交换到合适位置，重复n-1次(n-1趟)。 每一趟存在多次比较，找出最小的元素下标。 代码 123456789void selectionsorSort(int a[], int n)&#123; for(i=0;i&lt;n-1;i++)&#123; k = i; for(j=i+1;j&lt;n;j++)&#123; if(a[j] &lt; a[k]) k=j; // 最小元素下标 &#125; if(k!=i) a[i]←→[k]; &#125;&#125; 性能分析 1) 时间复杂度为O(n^2)2) 循环的执行次数与初始序列无关。3) 空间复杂度为O(1)4) 简单选择为不稳定的算法。 2) 堆排序(适用于关键字较多) 堆排序可以看成一棵完全二叉树，任何非叶结点的值，都不大于其左右孩子结点的值。 大顶堆(升序)：父结点大，孩子小(大顶堆的堆顶为最大元素)。 小顶堆(降序)：孩子大，父结点小(小顶堆的堆顶为最小元素)。 例题：判断是否构成堆 建立堆(筛选法，反复筛选的过程)，插入结点，删除结点 1234插入结点：插入结点时候，需要先将插入的结点x，放在最低层的最右边，然后对插入后的堆进行调整。删除结点：删除结点时候，用最底层最右边的结点，覆盖删除结点的位置，并重新调整。用筛选法构造初始堆，n个元素，必须从第 n/2下取整 个元素开始进行筛选。 例题：堆排序 123步骤：1) 首先建好大顶堆(或小顶堆)，输出堆顶x，再将堆顶元素x和最后一个元素y(编号最后)交换。2) 重新调整，并重复 如题： 代码： 1234567891011121314151617181920212223242526typedef sqlist HeapType; // 顺序表存储void HeapAdjust(HeapType &amp;H, int s, int m)&#123; rc = H.r[s]; for(j=2*s; j≤m; j*=2)&#123; if(j&lt;m &amp;&amp; (H.r[j].key &lt; H.r[j+1].key)) ++j; if(rc.key ≥ H.r[j].key) break; H.r[s] = H.r[j]; s= j; &#125; H.r[s] = rc; //插入 &#125; void Heapsort(HeapType &amp;H)&#123; // 对顺序表H进行堆排序 // 这里是将顺序表构建为堆 for(i=H.length/2;i&gt;0; --i)&#123; // 最后一个非叶子结点开始筛选，最后一个非叶节点为length/2。 HeadAdjust(H,i,H.length); &#125; for(i=H.length; i&gt;1; --i)&#123; H.r[1] ↔ H.r[i]; // 将堆顶元素和当前未经排序子序列H.r[1...i]的最后一个记录互换 HeapAdjust(H,1,i-1); // 将剩余的H.r[1...i-1]重新调整为大顶堆 &#125; &#125; 性能分析 堆排序不稳定。 建立堆的时间复杂度为O(n), 时间复杂度最好，最坏，平均都为O(nlogn) 空间复杂度为O(1) 适用于关键字较多的情况(例如：10000个关键字选出前10个) 以二叉树的任意结点出发到根的路径上所经过的结点序列按其关键字有序。 具有n个结点插入新元素的时间复杂度为O(logn)，删除一个元素的时间复杂度为O(logn) 2路归并排序 例题 性能分析 1231. 时间复杂度为O(nlogn)2. 空间复杂度为O(n)3. 归并排序一轮不会确定一个元素的最终位置。 基数排序 多关键字排序 最高位优先：先按最高位排成若干子序列，然后在对子序列按次高排序。 最低位优先：采用“分配”和“收集”策略。 例题 性能分析 1231. 对n个元素进行基数排序，每个数据基数为rd(基数为每个位的范围，例如从0-9)，有d位数字(每个关键字位数)，一趟分配和收集用时n+rd，共d趟，故总时间复杂度为O(d(n+rd))2. 基数排序为稳定算法。3. 基数排序，不需要进行关键字比较。 内部排序总结 时间复杂度：平均情况下，快排，希尔，堆排序，归并排序，时间复杂度都为O(nlog2n)，其余都为O(n^2) 空间复杂度：快排O(log2n)，归并为O(n)，基数为O(rd)，其余都为O(1) 直接插入和冒泡，在初始序列已经有序时，时间复杂度为O(n) 稳定性：快排，希尔，堆排序，简单选择，四种为不稳定，其余都为稳定。 经过一趟排序，可以保证关键字达到最终位置，是交换类(气泡，快排)和选择类(简单选择，堆)排序。 关键字比较次数与初始序列无关：简单选择和折半插入 排序趟数与原始序列有关：交换类(冒泡，快排) 外部排序总结 m个初始归并段进行k路归并，归并的趟数为┌logkm┐ 每一次归并，所有记录都要进行两次I/O操作 置换-选择排序中，所有记录都要进行两次I/O操作 K路归并的败者树的高度为┌log2k┐+1，因此利用败者树从k个记录中选出最值需要进行┌log2k┐次比较，即时间复杂度为O(log2k) k路归并败者树的建树时间复杂度为O(klog2k)]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>快速排序</tag>
        <tag>希尔排序</tag>
        <tag>堆排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查找总结]]></title>
    <url>%2F2021%2F01%2F07%2F%E6%9F%A5%E6%89%BE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[基本概念 静态查找表：只进行查找操作，例如：顺序查找，折半查找，索引顺序表。 动态查找表：可进行查找，插入，删除，例如：二叉排序树，平衡二叉树(AVL树)，B树等。 平均查找长度(ASL)：关键字比较次数的平均值。 顺序查找 特点：简单，既可以顺序，也可以链式。 等概率情况下，查找成功的平均查找长度：ASL=(1+2+3..+n)/n = (1+n)/2。(第一次查找成功，比较1次，第二次比较两次成功…) 顺序查找的判定树为一棵深度为n的单分支的树。 时间复杂度为O(n) 代码： 12345678910# 在数组a的前n个元素中查找xint search(int a[], int n, int x) // n为长度，x为要查找的元素&#123; for (int i = n-1; i&gt;= 0;i++)&#123; if (a[i] == x)&#123; return i; &#125; &#125; return -1; //未找到&#125; 折半查找 适用于有序的顺序表，只能顺序存储结构。 代码 123456789101112131415161718192021222324252627282930313233// 非递归折半查找int binarysearch(int a[], int n, int x)&#123; low = 0; high = n-1; while(low &lt;= high)&#123; mid = (low + high) /2; if(a[mid] &gt; x)&#123; high = mid -1; &#125;else if(a[mid] &lt; x)&#123; low = mid +1; &#125;else&#123; return mid; &#125; &#125; return -1;&#125;// 递归折半查找int binarysearch(int a[], int low, int high, int x)&#123; if (low &gt; high)&#123; return -1; &#125; mid = (low+high)/2; if (a[mid] == x)&#123; return mid; &#125; else if (a[mid] &gt; x)&#123; return binarysearch(a, low, mid-1, x); &#125;else&#123; return biarysearch(a, mid+1, high, x); &#125;&#125; 判定树类似于完全二叉树，深度为 └log2n┘+1 画判定树 例如：画出n=10的有序表折半查找的判定树。 时间复杂度为O(logn) 索引顺序表 分块，块间有序，块内无序，对应索引表有序，顺序表无序。 索引顺序表的查找性能在顺序查找和折半查找之间。 查找过程： 先确定待查记录所在块(顺序，折半查找)。 在块内查找(顺序查找，因为块内无序) 平均查找长度ASL= Lb + Lw 既希望较快的查找，又便于线性表动态变化的查找方法是：索引顺序查找 例题：123456789具有144个记录，采用分块查找。索引和顺序表都采用顺序查找，每块长度为8，则平均查找长度为解： ASL = lb + lw 144/8 = 18块 lb = (1+2+3+...+18) /18 = 19/2 // 等概率 lw = (1+2+3+...8)/8 = 9/2 ASL = 19/2+9/2 = 14 如果索引表折半查找，要计算折半查找平均查找长度 + 顺序表内的顺序查找平均查找长度 二叉排序树 二叉排序树：空树或这样的一棵树，左子树不空，则左子树所有结点均小于根结点，若右子树不空，则右子树所有结点，均大于根结点。 若用中序遍历二叉排序树得到结果将从小到大有序。 二叉排序树查找算法： 123456789101112131415161718192021222324252627 # 递归算法查找 Bitree BstSearch(Bitree bst, int x)&#123; if (bst == NULL)&#123; rerurn NULL; &#125; if (bst-&gt;data &gt; x)&#123; // 如果大于x，说明要查找的值在左子树 return BstSearch(bst-&gt;lchild, x); &#125;else if (bst-&gt;data &lt; x)&#123; return BstSearch(bst-&gt;rchild, x); &#125;else&#123; return bst; &#125; &#125; # 非递归查找Bitree BstSearch(Bitree bst, int x)&#123; p = bst; while(p)&#123; if (p-&gt;data == x)&#123; return p; &#125;else if (p-&gt;data &gt;x)&#123; p = p-&gt;lchild; &#125;else&#123; p = p-&gt;rchild; &#125; &#125; return NULL;&#125; 二叉排序树插入步骤： 1234567891011121314151617181) 若为空树，直接插入2) 若非空，首先查找这个元素是否存在，如果存在，什么也不做，如果不存在，则插入到合适位置。(查找不成功的位置，即为插入位置)int BST_Insert(Bitree &amp;T, int k)&#123; if(T==NULL)&#123; // 当前为空，说明找到了插入位置，创建新节点进行插入 T = (Bintree)malloc(sizeof(BNode)); T-&gt;data = k; T-&gt;lchild = T-&gt;rchild = NULL; return 1; // 成功 &#125; else if(k == T-&gt;data)&#123; // 存在相同关键字 return 0; &#125;else if(k &lt; T-&gt;data)&#123; return BST_Insert(T-&gt;lchild, k); &#125;else&#123; return BST_insert(T-&gt;rchild, k); &#125;&#125; 插入操作时，新插入的结点总是叶子结点。 二叉排序树构造就是多次调用插入操作。 12345678void create_BST(Bitree &amp;T, int keys[], int n)&#123; T = NULL; // 创始化 int i=0; while(i&lt;n)&#123; BST_Insert(T, keys[i]); // 依次插入关键字 i++; &#125;&#125; 二叉排序树删除步骤 1231) 删除叶子结点，直接删除。2) 删除的结点有左子树或者有右子树(有其中一个)，则子树替代删除结点位置。3) 删除结点左右子树都存在，则将二叉树按中序遍历，序列的直接后继(直接前驱也行)代替，并删除直接后继(前驱)。 计算平均查找长度ASL=(第一层x个数+第二层x个数+第三层x个数+..)/结点总个数。 平均查找长度也为O(logn) 如果二叉树插入结点之后为单支树，则查找退化为顺序查找，平均查找长度为 (1+n)/2 二叉排序树和二分查找判定树区别：二分查找判定树唯一，二叉排序树查找不唯一，相同关键字插入顺序不同可能会导致生成不同的二叉排序树。 平衡二叉树 平衡因子：左子树深度-右子树深度 平衡二叉树平衡因子只能为0，1，-1 平衡二叉树是特殊的二叉排序树 失去平衡时候调整 1234步骤： 1) 首先找失去平衡的最小子树 2) 根据相对判断类型 3) 调整，按照大小值，谁在中间，谁做根结点。 画图 平均查找长度也是(第一层乘个数+第二层乘个数+...)/个数 求n个结点的平衡二叉树最大高度：即求高度为h的平衡二叉树的最少结点。也是非叶子结点，所有平衡因子都为1的情况) 求高度为h的平衡树的最少结点数公式：nh= Fh+2-1，其中F为斐波拉契数列第h+2项，当Fh=0，1，2，当h为0，1，2时 B-树和B+树 二叉排序树为二路查找，B-树为多路查找。 一棵m阶的B-树，或为空树，或满足：1) 每个结点至多有m个子树(分支)(即最多m-1个关键字)；2) 若根结点，不是叶子结点，则至少两棵子树(一个关键字)；3) 除了根，叶子结点之外的结点，至少有┌m/2┐棵子树；4) 所有叶子结点在同一层，不含信息，表示查找失败。5) 具有n个关键字的m阶B树，则有n+1个叶结点(查找失败)。 B-树的查找 B-树的创建(多次插入操作)注意：操作时，首先计算每个结点关键字个数，例如：m阶B树，每个结点最多m-1个关键字，根结点最少一个关键字，非根结点的非叶子结点，最少是┌m/2┐-1个关键字，最多m-1个关键字。 B-树的删除 12345678910111. 要删除的结点在终端结点(叶子结点) 1) 要删除的结点内关键字个数＞┌m/2┐-1，此时可以直接删除。(关键字个数大于最小值) 2) 要删除的结点内关键字个数＝最小值┌m/2┐-1，其中左，右兄弟结点中存在关键字个数大于最小值┌m/2┐-1的结点，则从兄弟结点借关键字。然后通过父结点调整。 3) 要删除的结点关键字个数＝最小值┌m/2┐-1，左右兄弟关键字个数等于最小值(不能借)，这时要结点合并，讲剩余结点的关键字与父结点的关键字进行合并，双亲结点下来与孩子合并，双亲结点关键字减1。 2. 要删除的结点不终端结点 1) 如果关键字的左右子树中存在大于┌m/2┐-1结点，则左子树找最右边关键字(删除关键字的前驱)，右子树找最左边关键字(后继关键字)，覆盖要删除的关键字。 2) 如果关键字的左右子树都已经处于最小的关键字个数，则直接合并子结点，删除关键字 例题： B+树性质概念 n个关键字有n个分支。对比B树，n个关键字，n+1个分支 B+树的叶子结点包含信息。对比B树不包含。 B+树所有非叶子结点，只起索引作用，不包含关键字对应的存储地址。对比B树，每个结点关键字对应存储地址。 B+树有一指针指向最小的叶子结点，可进行顺序查找。 B+树有两种查找运算：一种是从最小关键字开始的顺序查找，另一种是从根节点开始的多路查找。 哈希表 对散列表进行查找的时间复杂度为O(1)，与表中元素个数无关。 哈希表的平均查找长度与n不直接相关，而是取决于装填因子（α=记录个数/地址空间）和处理冲突方法。 散列查找思想：计算出散列地址进行查找，然后比较关键字判断是否查找成功。 为了有效应用Hash表，必须解决的两个问题是构造Hash函数和确定解决冲突的办法 1. 构造散列函数方法1) 直接定址法 H(key) = a*key +b 特点：浪费空间，不会产生冲突 2) 除留取余法 H(key) = key % p // 假设表长m，其中p为不大于，或等于m的最大素数 3) 数字分析法 2. 处理冲突方法(冲突后，找下一个位置)注意：开放定址法，不能随意删除已有元素。 1) 开放定址法H = (H(key) + di) % m 线性探测再散列 H(key) + 1，H(key)+2，…容易造成“聚集”，从而降低查找效率，聚集是因为解决冲突的方法原则不当。 二次探测再散列 H(key) + 1^2，H(key) - 1^2，H(key) + 2^2，H(key) - 2^2，…解决聚集问题 伪随机探测再散列 H(key) + f(1)，H(key) + f(2)，… 注意：其中伪随机函数，题中会给 2) 链地址法 构造链表，将同一个地址的关键字存储在一个单链表中。 3) 再哈希法 3. 性能分析 除留取余+线性再散列例题 除留取余+链地址法 注意： 关于计算平均查找失败长度时，空位置是否计算在内：顺序表时，空位置的比较次数也要计算在内；链表(链地址法)时，空指针不计算在内。 计算查找失败平均查找长度时，如果除留取余法，分母为p，分子也应该只计算0-(p-1)的查找次数。 查找成功是除以关键字个数；查找失败除以模值。查找失败如果不是除留取余法，则除以散列表空间个数(例如0-15则除以16)。 采用开放定址法处理散列表冲突时，其平均查找长度是高于链地址法 。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>查找</tag>
        <tag>平衡二叉树</tag>
        <tag>B-树</tag>
        <tag>B+树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图及其应用]]></title>
    <url>%2F2021%2F01%2F07%2F%E5%9B%BE%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[图由结点和边的集合构成。(图不可为空图，树可为空树) 在无向图中，边(vi,vj)等价于有向图的&lt;vi,vj&gt;与&lt;vj,vi&gt;。 在无向图中，与顶点相关边的条数为顶点的度。 在有向图中，指向顶点的度，由顶点发出的边的条数为顶点的出度。 有向完全图：若有向图有n个顶点，则最多有n(n-1)条边[任意两个顶点两条边]。 无向完全图：有n个顶点，任意两个顶点之间都存在边，最多有n(n-1)/2条边。 连通：从顶点vi到顶点vj有路径，则vi与vj连通。 连通图：任意两个顶点之间都连通。 连通分量：极大连通子图(极大说的是包含所有边)。 在有向图中，若顶点vi与vj，从vi到vj，和从vj到vi都有路径，则称图为强连通图。 极大强连通子图称为强连通分量。 顶点为n个的无向连通图至少有n-1条边。 顶点为n个的有向强连通图则至少有n条边(此时构成环)。 生成树(极小连通子图)：保持连通，边最少，不唯一。 简单路径：顶点不重复出现的路径。 无向图的图的度：边数为无向图所有顶点度的一半。 图的存储结构邻接多重表只适用于无向图，十字链表适用于有向图，其余既可以无向图和有向图。 邻接矩阵法 图的顺序存储结构。适用于稠密图，邻接矩阵法空间复杂度为O(n^2)，与边的数目无关。 无向图中，矩阵是对称的，其中第i行或第i列的和为顶点i的度，并且唯一。 有向图中，邻接矩阵可能为对称。第i行元素和为顶点i的出度，第i列元素之和为顶点i的入度。 结构体定义 1234567const int Maxsize = 100 // 最大顶点数typedef struct Graph&#123; VertexType vexs[Maxsize]; // 顶点向量 可以定义为char类型 ArcType arcs[Maxsize][Maxsize]; // 邻接矩阵 int 类型 int vexnum,arcnum; // 顶点和边的个数&#125;Graph; 对于图(有向，无向)：有边为1，否则为0。 对于网(有向有权图)：有边为权值，否则为∞ 画图 对于无向图 对于有向图 对于网(有向有权图) 邻接表法 为每个顶点建立一个单链表，第i个结点的表头指针指向关于vi顶点的边表。邻接表法更适用于稀疏图。 ，且邻接表画图结果不唯一。 邻接表由顶点表(顺序存储)和边表(链式存储)组成。 邻接表占用存储空间与结点和边都有关。 结点 123456789101112131415顶点表(链域，数据域)firstarc data边表(邻接点域，链域，数据域)adjvex nextarc infotypedef struct node&#123; // 边表结点 int adjvex; // 该弧所指向的顶点的位置 struct node *next;&#125;EdgeNode;typedef struct vnode&#123; char data; // 顶点数据 EdgeNode *first; // 指向第一条该顶点的弧&#125;VNode; 在无向图中，顶点vi的度为第i结点指向的边表中结点数。 在有向图中，边表中结点数只是顶点i的出度。要求入度需要遍历整个邻接表。 画法 无向图 有向图 逆邻接表(为了方便确定顶点的入度) 十字链表 十字链表相当于邻接表和逆邻接表结合。 结点结构12345顶点结点(结点，指向入边第一个结点，指向出边第一个结点)data firstin firstout弧结点(头，尾，指向下一个入边，下一个出边)start end nextin nextout 画图 邻接多重表 适用于无向图，不能存储有向图。 例如：最适合稀疏无向图：邻接多重表。最适合稀疏有向图：十字链表。 图的遍历无论是深度优先，还是广度优先，时间复杂度采用邻接表时都为O(n+e)，空间复杂度为O(n)，采用邻接矩阵时时间复杂度为O(n^2)。 深度优先遍历 类似树的先根遍历 同一个图的深度优先遍历序列可能不同。 基本思想：首先访问出发点v，标记为已访问过，然后选取与v相邻的未访问的w，访问，然后选取与w相邻的未访问的顶点，重复。当所有相邻的顶点都访问过，依次退回到最近访问，然后找未访问顶点，重复上述访问操作，直到图中所有顶点访问结束。 可以利用深度优先遍历判断是否存在回路。 画图 代码实现 123456789101112131415161718192021222324bool visited[max_vertex_num]; // 标记访问数组void DFSTraverse(Graph G)&#123; // 初始化为false for(i=0;i&lt;G.vexnum;i++)&#123; visited[i] = false; &#125; //从0号开始遍历，遍历每个连通分量 for(i=0;i&lt;G.vexnum;i++)&#123; if(!visited[i])&#123; DFS(G, i); &#125; &#125;&#125;void DFS(Graph G, int v)&#123; visit(v); // 访问结点v visited[v] = true; // 将标记数组，标记为已访问 for(w=FirstNeighbor(G, v); w&gt;=0; w=NextNeighbor(G, v, w))&#123; // w为u的尚未访问的邻接结点 if(!visited[w])&#123; DFS(G, w); &#125; &#125;&#125; 广度优先遍历 类似层次遍历二叉树 广度优先遍历需要借助一队列。 广度优先生成树，若给定邻接矩阵存储则表示唯一，若给定邻接表则表示不唯一。 画图 代码12345678910111213141516171819202122232425262728bool visited[max_vex_num]; // 最大顶点个数，用于标记结点是否已被访问void BFSTraverse(Graph G)&#123; // 初始化 for(i=0;i&lt;G.vexnum;i++)&#123; visited[i] = false; &#125; InitQueue(Q); for(i=0;i&lt;G.vexnum;i++)&#123; // 从0号顶点开始遍历，且循环目的是对每个连通分量调用一次BFS if(!visited[i]) BFS(G, i); &#125;&#125; void BFS(Graph G, int v)&#123; visit(v); // 访问v顶点 visited[v] = true; Enqueue(Q, v); // 顶点v入队列 while(!isEmpty(Q))&#123; DeQueue(Q, v); // v出队 for(w=FirstNeighbor(G, v); w&gt;=0; w=nextNeighbor(G, v,w))&#123; // 获取所有与v邻接的顶点 if(!visited[w])&#123; // 逐个判断并访问 visit(w); visited[w] = true; Enqueue(Q, w); &#125; &#125; &#125;&#125; 最小生成树(MST)(带权值)[都是针对无向图](1) 最小生成树的边数为顶点数-1。(2) 最小生成树代价唯一，最小生成树的树形不唯一。 普里姆算法[要求代码] 从顶点出发每次选权值最小的边。 判断：无向图一定有唯一形态的最小代价生成树。(错) // 当所有权值不相同时，生成的最小生成树才唯一。 使用邻接矩阵存储时，时间复杂度为：O(n^2) 使用邻接表存储时，时间复杂度为：O(n+e) 适用于稠密图。特点：只与顶点个数n有关，与边的数目e无关。 画图 代码 克鲁斯卡尔算法 无需从顶点出发，只需要找权值边最小。 适用于稀疏图。特点：只与边的数目e有关，与定点个数n无关。 画图 时间复杂度为：O(eloge) // e为边数 拓扑排序(每次删除入度为0的顶点并输出) [不要求代码] 有向无环图(DAG)。AOV网 拓扑排序结果不一定唯一。 算法思想： 从DAG中选择一个 没有前驱结点的结点A(入度为0) 并输出 从图中删除所有以A为起点的边 重复1.2操作直到图为空，或者不存在无前驱顶点为止(存在环)。 画图 最短路径 迪杰斯特拉算法[要求代码] 用于求某一顶点到其余各顶点的最短路径。 迪杰斯特拉适合求解带回路的有权图的最短路径，也可以求任意两个顶点的最短路径，不适合求带负权值的最短路径问题。 画图 注意：图中的vj为从v0出发到vj的最短路径。再次比较时，用这个到其他顶点距离与原来距离比较。 代码 弗洛伊德算法 用于求每对顶点直间的最短路径 时间复杂度为O(n^3) 画图 关键路径(找最长的路径) AOE网，有向无环图。 边为活动或任务。 顶点为事件。 关键活动：关键路径上活动(边)为关键活动。 关键路径：从原点到汇点最大路径长度的路径称为关键路径。 事件(顶点)i：最早发生时间ve(vi)，最晚发生时间vl(vi)。 活动(边)：最早开始时间e(ai)，最晚开始时间l(ai)。 画图 事件最迟发生时间vl(vi)=ve(vi)，或者取min。 网中的关键路径不唯一，只有加快包含所有关键路径上的关键活动才能缩短工期，但也不能随意缩短，关键活动有可能变为非关键活动。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>图的遍历</tag>
        <tag>图的应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树和二叉树总结]]></title>
    <url>%2F2021%2F01%2F07%2F%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[树型结构是非线性数据结构。 结点的度：结点拥有的分支个数，节点度就是这个节点的孩子数量 。 树的度：树中结点度的最大值。 树的高度：树中结点的最大层数。 结点的深度：根结点到该结点路径结点个数。树的存储结构 顺序存储：双亲表示法 链式存储：孩子表示法和孩子兄弟表示法 双亲表示法用于找双亲效率高；孩子表示法和孩子兄弟表示法找孩子效率高，找双亲效率低。 度为m的总结点数：n0+n1+n2+n3+...+nm 总分支数：1*n1+2*n2+3*n3+4*n4+...+m*nm 总分支数=总结点数-1 二叉树(子树有左右之分，不能任意颠倒) 在二叉树第i层最多有2^(i-1)个结点。 深度为k的二叉树最多有(2^k)-1个结点。 对于任何一棵二叉树，如果叶结点为n0则度为2的结点数为n2，则n0=n2+1。 满二叉树和完全二叉树(除最后一层不满，其余层都是满的)。 具有n个结点的完全二叉树的深度为h＝└log2n┘+1。 n个结点的完全二叉树，结点按层次从1编号有： 结点i的双亲为└i/2┘,若i＝1时无根。 i结点的左孩子是2i i结点的右孩子是2i+1 结点为i所在的层为└log2i┘+1 n个叶子结点完全二叉树深度└log2(2n)┘+1 二叉树的存储结构结构定义：1234567891011// 二叉链表typedef struct BTNode&#123; DataType data; struct BTNode *lchild,*rchild;&#125;BTNode,*BinTree;// 三叉链表typedef struct BTNode&#123; DataType data; struct BTNode *lchild,*rchild,*parent;&#125;BTNode,*BinTree; 顺序存储：自上而下，自左而右的存储在一维数组，仅适合存储完全二叉树，第i号元素存储在一位数组下标的[i-1]位置。 链式存储：二叉链表和三叉链表 二叉链表：lchild + data + rchild 三叉链表： lchild + data + parent + rchild 二叉链表含有n个结点，有n+1个空指针。 2叉链表，n个结点，共2n个指针域，除了第一个结点，每个结点都有父结点，父结点指向子结点，故n-1个结点存放了地址，有2n-(n-1)=n+1个为空指针。 采用三叉链表有n个结点，有n+2个空指针。 五种二叉树形态 空树：bt == NULL 左右子树均为空： bt-&gt;lchild ==NULL &amp;&amp; bt-&gt;rchild ==NULL 右子树为空：bt-&gt;rchild == NULL 左子树为空：bt-&gt;lchild == NULL 左右子树均非空 n个结点可以构造多少种二叉树? 公式：1/(1+n)Cn.2n 遍历二叉树 每个结点仅被访问一次 先序遍历，中序遍历，后序遍历只有根结点访问的先后顺序有区别，其他(例如：两个结点的先后顺序，三种方法完全相同)没区别。 算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140// 先序遍历void Preorder(BTnode *bt)&#123; if (bt)&#123; visit(bt-&gt;data); Preorder(bt-&gt;lchild); Preorder(bt-&gt;rchild); &#125;&#125;// 中序遍历void InOrder(BTNode *bt)&#123; if (bt)&#123; InOrder(bt-&gt;lchild); visit(bt-&gt;data); // 移动到下面为后序遍历 InOrder(bt-&gt;rchild); &#125;&#125;// 层次遍历// 思路：利用一个队列，首先将根(头指针)入队列，以后若队列不空则取队头元素p，// 若p不空则访问，然后将其左右子树入队列，如此循环直到队列为空。void levelOrder(BinTree bt)&#123; initEqueue(Q); // Q为队列 Enqueue(Q, bt); // 根结点入队 while(!QueueEmpty(Q))&#123; DeQueue(Q, p); if (p)&#123; visit(p); Enqueue(p-&gt;lchild); Enqueue(p-&gt;rchild); &#125; &#125;&#125;// 使用循环队列的层次遍历void levelOrder(Bintree *bt)&#123; const int Maxsize = 1024; Bintree q[maxsize]; // 等同 BTNode * q[maxsize] int front, rear; // 初始化队列 front = rear = 0; // 根入队列 q[rear] = bt; rear = (rear +1)% maxsize; // 队列不空时循环 while(!front == rear)&#123; p = q[front]; front = (front +1) %maxsize; if (p)&#123; visit(p-&gt;data); q[rear] = p-&gt;lchild; rear = (rear +1)%maxsize; q[rear] =p-&gt;rchild; rear = (rear +1)%maxsize; &#125; &#125;&#125;// 非递归中序遍历思路：指针p从根开始，首先沿着左子树向下移动，同时入栈保存路径结点(不访问)，当到达空子树后需要退栈访问结点，然后移动到右子树。void InOrder(Bintree bt)&#123; InitStack(S); p = bt; while(p || !StackEmpty(S))&#123; if (p)&#123; Push(S, p); p = p-&gt;lchild; &#125;else&#123; Pop(S, p); visit(p); p = p-&gt;rchild; &#125; &#125;&#125;// 先序非递归void PreOrder(BtTree bt)&#123; initStack(S); p = bt; while (p || !StackEmpty(S))&#123; if (p)&#123; visit(p-&gt;data); Push(S, p); p = p-&gt;lchild; &#125; else&#123; pop(S, p); p = p-&gt;rchild; &#125; &#125;&#125;// 后序遍历非递归// 思路：分别从左子树和右子树两次返回根结点，只有从右子树返回时才访问根结点，增加一个栈标记到达结点的次序void PostOrder(Bintree bt)&#123; InitStack(S); InitStack(tag); p = bt; while(p || !StackEmpty(S))&#123; if (p)&#123; push(S, p) Push(tag, 1) // 第一次入栈标识 p = p-&gt;lchild; &#125;else&#123; // 从左子树返回，二次入栈，然后p转右子树 Pop(S, p); Pop(tag, f); if (f == 1)&#123; Push(S, p); Push(tag, 2); p = p-&gt;rchild; &#125;else&#123; // 从右子树返回，访问p，转上层 visit(p); p = NULL; // 使下一步继续退栈 &#125; &#125; &#125;&#125;// 三叉链表的中序遍历void InOrder(Bintree bt)&#123; if (bt == NULL)&#123; return; // 空树直接返回 &#125; p = bt; while(p -&gt;lchild) p = p-&gt;lchild; while(p)&#123; visit(p); if (p-&gt;rchild)&#123; p = p-&gt;rchild; &#125; &#125;&#125; 非空二叉树先序遍历和后序遍历具有相同的结点访问顺序，则一定只有根结点。 若非空二叉树先序遍历和后序遍历访问顺序相反，则二叉树所有结点无左孩子或无右孩子(向右斜线，或向左斜线)。 遍历二叉树应用题型：给出前，中，后序其中两个确定一棵二叉树。a. 已知前序和中序，可以唯一确定二叉树。 例如： b. 已知后序和中序，可以唯一确定二叉树。 例如： c. 已知前序和后序，不一定能确定。 虽然前序后序不能确定唯一二叉树，但可确定父子关系，例如：若前序为XY，后序为YX，则X为Y的父结点。 d. 算法123456789101112131415161718192021222324// 求二叉树结点的个数int NodeCount(Bintree bt)&#123; if (p == NULL)&#123; return 0; &#125; return 1+ NodeCount(bt-&gt;lchild) +NodeCount(bt-&gt;rchild);&#125;// 求二叉树的深度int Depth(Bintree bt)&#123; if (p == NULL)&#123; return 0; &#125; return 1+ max(Depth(p-&gt;lchild), Depth(p-&gt;rchild));&#125;// 求二叉树叶子结点的个数int LeafCount(Bintree bt)&#123; if (p == NULL)&#123; return 0; &#125; else if(bt-&gt;lchild == NULL &amp;&amp; bt-&gt;rchild ==NULL)&#123; return 1; &#125; else return LeafCount(bt-&gt;lchild) + LeafCount(bt-&gt;rchild);&#125; 线索二叉树引入二叉线索树目的是加快查找结点的前驱和后继。 结点结构(5部分) 1234lchild ltag data rtag rchild其中：ltag, rtag为标识位，当tag=0时表示child指针指向结点，当tag=1时，则表示child指针为线索，指向结点的前驱或者后继 线索化左边空指针可以作为前驱索引，右边空指针可以作为后继线索，可以全线索化(例如面的，先序和中序)，也可以部分线索化(例如：下面的后序)。 先序线索化 中序线索化 后序线索化(只画出后序的后继线索) 中序线索化代码实现 12345678910111213141516171819202122232425262728293031// 中序非递归遍历线索树typedef enum PointerTag&#123;Link, Thread&#125;; // Link=0 指针，Thread =1 线索 typedef struct BiThrNode&#123; EmemType data; struct BiThrNode *lchild, *rchild; PointerTag Ltag, Rtag; // 左右标志，为0时表示lchild指向左孩子，为1时表示指向前驱 &#125;BiThrNode, *BiThrTree; // 线索化，在线索链表添加一个头结点，头结点的lchild指向，原来的根结点，头结点的rchild指向原来线索链表中序遍历的的最后一个节点 // ，同时中序遍历的第一个节点的lchild和最后一个节点的rchild指向头结点。 Status InorderTraverse_Thr(BiThrTree T)&#123; // 这里T指向一个头结点，头结点的lchild指向根结点 BithrTree p; p = T-&gt;lchild; // p指向根结点， while(p != T)&#123; // 空树或者遍历结束时候p == T，此时p指向头结点 while(p-&gt;Ltag == link)&#123;p=p-&gt;lchild;&#125; printf(p-&gt;data); // 访问左子树为空的节点 while(p-&gt;Rtag == Thread &amp;&amp; p-&gt;rchild != T)&#123; p=p-&gt;rchild; printf(p-&gt;data); //访问后继节点 &#125; p = p-&gt;rchild; &#125; &#125; 后序线索树需要栈的支持。 二叉树线索化后，仍不能有效求解的问题是后序线索二叉树中求后序后继。(原因：先序遍历（中左右）、中序遍历（左中右）的最后访问的节点都是左或右叶节点，叶节点是没有子树的，所以两个指针域空出来了，可以存放线索指针。但是后续遍历（左右中），最后访问的是子树的根节点，而子树根节点的两个指针域都指向子树了，所以不能空出来存放线索信息。) 树的存储结构 双亲表示法1) 存储表示 123456789typedef struct PTNode&#123; // 结点结构 ElemType data; int parent; // 双亲位置(数组下标)&#125;PTNode;typedef struct&#123; PTNode nodes[max_tree_size]; int r, n; // 根位置和结点数&#125; 2) 画图 &gt; 孩子表示法1) 存储表示 1234567891011121314typedef struct CTNode&#123; // 孩子结点，孩子链表的结点 int child; struct CTNode* next;&#125;* ChildPtr;typedef struct&#123; ElemType data; ChildPtr firstchild; 孩子链表的头指针&#125;CTBox;typedef struct &#123; CTBox nodes[size]; int r, n; // 根的位置和结点数&#125; 孩子兄弟表示法1) 存储表示 1234typedef struct CSNode&#123; ElemType data; struct CSNode * firstchild, *nextsibling;&#125;CSNode, *CSTree; 2) 画图 树与二叉树的转换特点： 由树转化为二叉树，根结点无右孩子。题型：画图将树转为二叉树，并将二叉树转树。 森林和二叉树的转换题型：森林和二叉树相互转换 树和森林的遍历 树的先根遍历对应二叉树的先序遍历；树的后根遍历对应二叉树的中序遍历。 森林的先序遍历对应二叉树的先序遍历，森林的中序遍历对应二叉树的中序遍历。 赫夫曼树(最优二叉树)和赫夫曼编码特点：带权路径最短。 路径：是树从一个结点到另一个结点的 树的带权路径长度：所有叶子结点的带权路径长度之和，记作WPL。 性质： 每个初始结点都为叶结点。 权值越大离根结点越近，权值越小离根结点越远。 哈夫曼树没有度为1的结点。 n个叶子结点的哈夫曼树，结点总数为2n-1，其中度为2的结点个数为n-1。 构造赫夫曼树(每次取两个最小的树组成二叉树)注意：同样一组权值可能构造不同的霍夫曼树，但是带权路径长度一定是一样的。 霍夫曼编码(前缀码)左分支为0，右分支为1，从根到叶子的路径构成叶子的前缀编码。 赫夫曼n叉树 若构造n叉树时，发现结点不能构造时，需要补上权值为0的结点，让序列构成霍夫曼叉树序列。 此时只有度为0和度为n的结点 判断字符是不是前缀编码? 123456789只需要判断是否有其他编码以这个编码开头。A. 01 0000 0001 001 1D. 0 100 110 1110 1100看A 的01 比较0000 0001 001 1都不是01开头看A 的0000 比较，不存在其他相同，比较完发现A是前缀编码。看D 比较后发现110 是1100的开头。故D不为前缀编码 一棵哈夫曼树215个结点，对其进行编码，共得到多少个码字? 123n0+n2 =215n0 = n2 + 1带去可得n0 = 108 只有叶子结点有关键字值，非叶结点无关键字值。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>二叉树</tag>
        <tag>遍历二叉树</tag>
        <tag>线索二叉树</tag>
        <tag>霍夫曼树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组和广义表]]></title>
    <url>%2F2021%2F01%2F07%2F%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[数组是一组类型相同，下标不同的变量构成，是逻辑结构。 数组特点：元素有统一的类型，下标有固定上界和下界，数组一旦被定义，它的纬数和维界就不在改变。 数组除了初始化和销毁外，只能修改，存取两个操作。 特殊矩阵：对称矩阵，三角阵，对角阵。 对称矩阵主对角线上下对阵，只需要保存一份。 稀疏矩阵：顺序存储+链式存储。 顺序存储：三元组表示法 三元组转置 快速转置 cpot表示，M(转置前)中第col列的第一个非零元素在b.data中位置。 链式存储：十字链表画图 广义表：元素可以是原子或者广义表的一种线性结构。 广义表的长度：最上层元素的个数。 广义表的深度：括号的最大层数。 表头(HEAD)和表尾(Tail)：广义表非空时，第一个元素为广义表的表头，其余元素组成的表为广义表的表尾。 广义表的题型 123456789101112131415A = () # A是空表，长度为0，深度为1B = (d, e) # B的元素都为原子，长度为2，深度为1C = (b, (c,d)) # C的元素为原子b和另一个广义表(c,d),长度为2，深度为2D = (B,C) # 元素为两个广义表，长度为2，深度为3E = (a,E) # 元素为原子，和他本身，长度为2，深度为无限# Head和Tail的求法例子Head(B) = d Tail(B) = (e) Head(D) = B Tail(D) = (C)Head((a)) = (a) Tail((a)) = ()Head(A)与Tail(A) # 无定义Head(()) = () Tail(()) = ()注意：取Tail() = (内容)，先加一层括号， 任何非空广义表的表头可以为原子和子表，但表尾只能是子表。例如：Tail(B) = (e) 广义表的存储结构：链式存储 头尾链表存储结构作图两种结点结构： 原子结点[tag=0,数据域]； 子表结点[tag=1,指向表头指针,指向表尾指针] 扩展线性表存储结构作图两种结点结构： 原子结点：[标记域，数据域，尾指针域] 广义表结点：[标记域，表头指针域，表尾指针域] 注意：相当于带结点的链表，第一个为头节点，然后头结点的表头域指向下一层，第一层长度是几，建立几个节点，横向链接，然后建立第二层的节点，类推。 稀疏矩阵的压缩存储后便失去随机存取的特性。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[串总结]]></title>
    <url>%2F2021%2F01%2F07%2F%E4%B8%B2%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[串是逻辑结构，是限定元素为字符的线性表，用单引号括起来的字符序列是串的值。 空串：零个字符的串，长度为0。 空格串：由空格组成的串。 子串：串中的任意连续的子序列。 子串在主串中位置：子串中第一个字符在主串中位置(从1开始)。 主串：包含子串的串。 串相等：长度相等，对应字符相等。 模式匹配是串的一种重要操作。(模式匹配就是找子串的位置) 串的存储结构：①定长顺序串;②堆分配存储;③块链存储 基本操作： 123456789assign(s,t) // 将t赋值给screate(s,cs) // 讲cs字符创建为字符串Equal(s,t) // 判断s与t是否相等Length(s) // 求s的长度Concat(s,t) // 串连接，返回连接后新串。例如：concat(&quot;ab&quot;, &quot;cd&quot;) = &quot;abcd&quot;Substr(s,pos,len) // 从pos位置开始取len长度的子串。pos从1开始取，且包含pos位置Index(s,t) // 求子串t在中位置，查找失败时候返回0。例如Index(&quot;abc&quot;,&quot;ab&quot;)=1replace(s,t,v) // 将s中的t字符串用v替代。例如replace(&quot;abc&quot;,&quot;ab&quot;, &quot;d&quot;)=&quot;dc&quot;subcompare(s, t) // 比较字符串大小。若s＞t，返回值＞0;s小于t时，返回值小于0;s=t时，返回值=0 模式匹配算法 简单模式匹配 12345678910111213141516# 简单模式匹配int index(String s, String t)&#123; i = 1; j = 1; // 字符串从数组下标1开始存储 while(i&lt;s[0] &amp;&amp; j &lt;= t[0])&#123; // 其中下标为0存储字符串的长度 if(s[i] == t[j])&#123; i++; j++; &#125; else&#123; i = i -j +2; // 例如abdc与abc模式匹配，当i =3,j =3时，匹配失败，i回退到b的位置即3-3+2是b的下标 j = 1; &#125; &#125; if(j &gt; T[0])return i - T[0]; else return 0;&#125; kmp算法 12345678910111213141516171819# kmp算法手算前缀：例如'ababa'的前缀(除去最后一个字符) ：&#123;a,ab,aba,abab&#125;后缀：例如上式的后缀(除去第一个字符)：&#123;a,ba,aba,baba&#125;例如：求模式串T="abababcabc"的next数组值。步骤：1) 找除去第j位的前面几位的前缀和后缀。例如当j为3时对应字符为a，找ab的前缀和后缀最大相同长度2) 找最长的前缀和后缀相等。3) 将最长相等数+1。本题：① 第一位默认为0。(j等于1时)② 第二位为默认为0+1为1③ 第三位为ab的最大前缀和后缀中相同，前缀为&#123;a&#125;，后缀为&#123;b&#125;即最大相同为0，则next值为0+1为1④ 第四位找aba的最大前缀和后缀相同，前缀为&#123;a,ab&#125;,后缀为&#123;a, ba&#125;即最大相同长度为1，则next值为1+1=2⑤ 全部结果0112345123时间复杂度为O(m+n) //模式串m，正文串n kmp算法改进 12345678910111213141516# kmp算法改进例如：已知模式串为T="abababcabc",则nextva函数值。步骤：1) 写出next数组2) 写nextval数组，当第一位时，对应的值为0，即nextval[1] = 03) 当j＞1时，若T[j] ≠ T[next[j]]时，nextval[j] = next[j]；若T[j] = T[next[j]]时，nextval[j] = nextval[next[j]]本题：第一位默认0；第二位比较T[2]内容为b与T[next[2]]即T[1]内容为a，则不想等则nextval[2]=next[2]；第三位比较T[3]内容为a与T[next[3]]即T[1]内容为a，此时相等，nextval为nextval[next[3]]即为0；第四位比较T[4]与T[next[4]]即T[2]，相等，此时nextval为nextval[next[4]]=1；第五位比较T[5]与T[next[5]]，此时相等，nextval为nextval[next[5]]即为0；最后可得0101015013 求nextval的值]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>串</tag>
        <tag>KMP算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈和队列总结]]></title>
    <url>%2F2021%2F01%2F07%2F%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[栈和队列是两种重要的线性结构。是操作受限的线性表。 栈只能在一端进行插入和删除操作。 栈的特点：后进先出LIFO。 栈的两种存储方式：顺序栈，链栈。 进栈操作：先赋值在加一(栈顶指针始终在栈顶元素的下一个位置上)。 出栈操作：先减1，再取值。 关于n个元素可能得到出栈不同排列个数：1/(1+n)Cn.2n 队列在一端进行插入(队尾rear),在另一端进行删除(队头front)。 队列特点：先进先出(FIFO)。 队列的存储结构：顺序队和链队。 结构体定义1234567891011121314151617181920212223242526272829# 顺序栈typedef struct&#123; int data[maxsize]; int top; // 总是指向栈顶&#125;SqStack;#链栈 就是单链表typedef struct LNode&#123; int data; struct LNode *next;&#125;LNode;# 链式队列typedef struct QNode&#123; int data; struct QNode *next;&#125;QNode; // 结点定义typedef struct &#123; QNode * front; // 队头指针 QNode * rear; // 队尾指针&#125;LinkQueue;# 循环队列const int maxsize = 50;typedef struct &#123; ElemType elem[maxsize]; int front, rear; // 对头队尾位置&#125;SqQueue; 顺序栈 栈空条件：s.top == 0; 栈满条件：s.top == maxsize; 基本算法1234567891011121314151617181920212223# 入栈操作bool push(SqStack &amp;s, ElemType x)&#123; if (s.top == maxsize)&#123; return false; &#125; // 先赋值在加1，top总是指向栈顶的下一个 s.data[s.top]=x; s.top++; return true;&#125;# 出栈操作bool pop(SqStack &amp;s, ElemType &amp;x)&#123; if (s.top == 0)&#123; retun false; &#125; // 先减1，再取值 s.top--; x = s.data[s.top]; return true;&#125;#取栈顶元素s.data[s.top-1] 共享栈 将两个栈的栈低分别设置在共享空间的两端，两个栈顶向共享空间中间延伸。 链栈(不带头结点) 栈空条件：S == NULL。 链栈的所有操作都是在表头进行。如图 基本算法 1234567891011121314151617181920# 入栈bool push(LinkStack &amp;s, ElemType x)&#123; p = (LNode *)malloc(sizeof(LNode)); p-&gt;data = x; p-&gt;next = s; s = p return true;&#125;# 出栈bool pop(LinkStack &amp;l, ElemType &amp;x)&#123; if (s == NULL)&#123; return false; &#125; x = l-&gt;data; p = s; s = s-&gt;next; free(p); return true;&#125; 链队列(带头节点)实质是同时带有队头指针和队尾指针的单链表。如图: 队列为空条件：Q.front == Q.rear。// 头指针和尾指针都指向头结点 Q.front总是指向头结点，Q.rear总是指向最后一个结点。 注：如果队列只有一个元素时，队头也是队尾，删除队头元素也要修改队尾指针(同时指向头节点)(删除操作时，可能头，尾指针都要修改)。 基本算法： 1)入队列 123456789# 入队列bool Enqueue(LinkQueue &amp;Q, EmemType x)&#123; p = (LNode *)malloc(sizeof(LNode)); p-&gt;data = x; p-&gt;next = NULL; Q.rear-&gt;next = p; Q.rear = p; return true;&#125; 2)出队列 1234567891011121314# 出队列bool DequeuQueue(LinkQueue &amp;Q,ElemType &amp;x)&#123; if (Q.front == Q.rear)&#123; // 空栈 return false; &#125; p = Q.front-&gt;next; Q.front-&gt;next = p-&gt;next; x = p-&gt;data; if(Q.rear == p)&#123; Q.rear = Q.front; &#125; free(p); return true;&#125; 循环队列 区分队空队满两种方式：通常少用一个元素来区分队空和对列满；也可以加tag作为一标志。 约定front指向队头元素，rear指向队尾元素的下一个位置。 当少用一元素时 队列空条件：Q.rear == Q.front 队列满的条件：(Q.rear+1) % MAXSIZE == Q.front 队列中元素的个数：(Q.rear -Q.front+Maxsize) % Maxsize 当加标志时 队列空和满时条件都为Q.front == Q.rear 再用tag标志区分。 队列空时：Q.front == Q.rear &amp;&amp; Q.tag == 0 // 在删除最后一个元素同时将tag置为0，则为空 队列满时：Q.front == Q.rear &amp;&amp; Q.tag == 1 基本算法 1234567891011121314151617181920212223242526272829303132333435363738394041424344# 1. 少一个元素空间# 入队列bool Enqueue(SqQueue &amp;Q, DataType x)&#123; if((Q.rear +1)%maxsize==Q.front)&#123; return false; &#125; Q.elem[e.rear] = x; Q.rear = (Q.rear + 1) %maxsize; return true;&#125;# 出队x = Q.elem[Q.front];Q.front = (Q.front +1)%maxsize;# 2. 使用tag标记# 初始化void init(SqQueue &amp;Q)&#123; Q.front = Q.rear = 0; Q.tag = 0;&#125;# 入队bool Enqueue(SqQueue &amp;Q)&#123; if(Q.front == Q.rear &amp;&amp; Q.tag == 1)&#123; return false; &#125; Q.elem[Q.rear] = x; Q.rear = (Q.rear+1) %maxsize; if (Q.tag == 0) Q.tag = 1; return true;&#125;#出队bool DeQueue(SqQueue &amp;Q, ElemType &amp;x)&#123; if (Q.front == Q.rear &amp;&amp; Q.tag == 0)&#123; // 上一个操作是出队tag为0 return false; &#125; x = Q.elem[Q.front]; Q.front = (Q.front +1)%maxsize; if (Q.front == Q.rear) // 最后一个元素出队，front移动一位置到rear，正好两个指针相等 Q.tag = 0; return true;&#125; 注： 当前循环队列元素个数：(rear - front + maxsize) % maxsize 当前循环队列剩余空间个数：(front - rear +maxsize) % maxsize 栈和队列应用 表达式求值(前缀，中缀，后缀转换) 123456789例如： 表达式为(中缀)： [(A+B)*c] -(E-F) 中缀转前缀表达式计算(先乘除，后加减，先括号内，后括号外)： +AB -EF *+ABC -EF -*+ABC-EF 中缀转后缀： AB+ EF- AB+C* EF- AB+C*EF-- 计算： 括号匹配1234567891011121314151617181920212223242526# 检查输入的表达式括号是否匹配bool matchBrackets()&#123; const int Maxsize = 1024; // 栈最大容量 char s[maxsize]; int top=0; //栈顶 ch = getchar(); while(ch!=EOF)&#123; switch(ch)&#123; case &apos;(&apos;,&apos;[&apos;,&apos;&#123;&apos;: s[top++] = ch; // 先赋值在加一 break; case &apos;)&apos;: if(top == 0 || s[--top] != &apos;(&apos;)) return false; case &apos;]&apos;: if (top == 0 || s[--top] != &apos;[&apos;) return false; case &apos;&#125;&apos;: if (top == 0|| s[--top] != &apos;&#123;&apos;) return false; &#125; ch = getchar(); &#125; if (top == 0)return true; else return false;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性表总结.md]]></title>
    <url>%2F2021%2F01%2F07%2F%E7%BA%BF%E6%80%A7%E8%A1%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[线性表是相同类型数据元素的有限序列，也是一种逻辑结构。 线性表特点:存在唯一的一个被称为’第一个’的数据元素；存在唯一一个被称为’最后一个’的元素；除第一个元素，其余都有一个’前驱’，除最后一个，都有一个’后继’。 题型:计算二维数组按行(列)优先方式存放，指定元素的起始地址123例如:二维数组M[i][j]，每个元素长度为3字节，行下标0-7，列下标j从0-9，首地址为In,若按行优先存放，则M[7][6]的起始地址为In+(7*10+6)*3。若按列优先存放，则地址In+(6*8+7)*3 线性表的结构体定义123456789101112131415161718192021#define maxsize 100# 顺序表定义int A[maxsize];int length;# 链表结构体定义(单链表；循环单链表，最后结点指向头结点)typedef struct LNode&#123; int data; struct LNode *next;&#125;LNode;# 双链表结构体定义typedef struct DLNode&#123; int data; struct DLNode *prior; // 指向前驱的指针 struct DLNode *next;&#125;DLNode;# 动态分配内存L.data = (ElemType *)malloc(sizeof(ElemType)*size); 顺序表-线性表顺序存储结构 特点: 逻辑相邻，物理也相邻；随机访问。 顺序表为空：L.length == 0 顺序表满：L.length == Maxsize 基本算法 12345678910111213141516171819202122232425262728293031323334353637# (1) 查找算法for (i = 0; i &lt; L.length; i++) if(L.data[i]==x) break； if (i&lt;L.length) // 如果没有找到，最后一次循环，i==L.length了 return i；// 找到了 else 未找到 # (2) 插入算法bool Sqlistinsert(SqList &amp;L,int i,ElemType x) // 这里i取值从1至length+1&#123; // 如果长度大于L.length+1时超过数组下标范围 if (i &gt; L.length+1 || L.length==Maxsize || i&lt;1) &#123; return false； &#125; for(j = L.length; j &gt; i-1;j--) L.data[j]=L.data[j-1]； L.data[i-1] = x； L.length++； return true；&#125;# (3) 删除算法其中i的范围同上bool listDelete(SqlList &amp;L,int i, ElemType &amp;x)&#123; if (i &lt; 1|| i &gt; L.length||L.length==0)&#123; return false; &#125; x = L.data[i-1]; for(j=i; j&lt;L.length;j++)&#123; L.data[j-1]=L.data[j]; &#125; L.length--; return true;&#125; 算法分析 插入，删除时，时间复杂度为O(n)，在尾端插入，删除时时间复杂度为O(1) 插入时平均移动次数，表长为n，若在任意结点后插入(任意结点前插入)，插入位置有n个，平均移动次数(1+n)/2；在任意位置插入，插入位置有n+1个位置，平均移动次数n/2 删除时移动元素n-1/2 单链表 特点：用指针表示数据之间的逻辑关系。(逻辑相近的元素，物理位置不一定相邻) 带头结点单链表判空：L-&gt;next=NULL;单链表不空条件：L-&gt;next=NULL; 基本算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117# (1) 顺序访问所有元素void printvalue(Linklist &amp;L)&#123; p = L-&gt;next; while (p !=NULL)&#123; visit(p-&gt;data); p = p-&gt;next; &#125;&#125;# (2) 查找元素x,找到返回地址Linist Find(Linklist L, ElemType x)&#123; p = L-&gt;next; wile (p != NULL)&#123; if (p.data == x) return p; &#125; return NULL;&#125;# (3) 查找元素，先到返回位序int Find(LinkList L,ElemType x)&#123; p = p-&gt;next; int i = 0; while (p!=NULL)&#123; i++; if (p-&gt;data==x)&#123; return i; &#125; p = p-&gt;next; &#125; return i;&#125;# (4) 查找第i个位置Linklist Get(Linklist L, int i)&#123; // i的取值从1开始 p = p-&gt;next; j = 1; while (p!=NULL &amp;&amp; j &lt; i)&#123; p = p-&gt;next; j++; &#125; if (p &amp;&amp; j == i)&#123; return p; &#125; return NULL;&#125;# (5) 插入算法bool insertLit(Linklist &amp;L, int i, ElemType x)&#123; // 插入到第i的位置,例如插入到2位置，的指针应该指向1的元素位置 p = L; j = 0; // 首先找到第i的元素(1--n) while(p &amp;&amp; j &lt; i-1)&#123; p = p-&gt;next; j++; &#125; if(p &amp;&amp; j== i-1)&#123; t = (Linklist)malloc(sizeof(LNode); t-&gt;data = x; t-&gt;next=p-&gt;net; p-&gt;next = t; return true; &#125; return false;&#125;# (6) 删除算法bool LinklistDelete(LinkList L, int i, ElemType &amp;x)&#123; // 找到i-1的元素位置(从1开始) p = L; j = 0; while (p &amp;&amp; j &lt; i-1)&#123; p = p-&gt;next; j++; &#125; if(p &amp;&amp; j == i-1 &amp;&amp; p-&gt;next)&#123; x = p-&gt;next-&gt;data; s = p-&gt;next; p-&gt;next = s-&gt;next; free(s); return true; &#125; return false;&#125;# (7) 链表创建void createLinkList(Linklist &amp;L, int n)&#123; // 尾插法插入n个元素 L = (Linklist)malloc(sizeof(LNode); L-&gt;next = NULL; p = L; for(int i =0; i&lt;n;i++)&#123; scanf(x); s = (Linklist)malloc(sizeof(LNode)); s-&gt;data = x; s-&gt;next = p-&gt;next; p-&gt;next = s; p = s; &#125;&#125;// 头插法s = (Linklist)malloc(sizeof(LNode));s-&gt;data = x;s-&gt;next = L-&gt;next;L-&gt;next = s;# (8) 将两个有序链表合并为一个void merge(LinkList &amp;La, linLinklist &amp;Lb, Linklist &amp;Lc)&#123; pa = La.next; pb =Lb.next; Lc = pc =La; // La的头节点当做Lc的头节点 while(pa &amp;&amp; pb)&#123; if (pa-&gt;data &lt;= pb-&gt;data)&#123; pc-&gt;next = pa; pc = pa; pa = pa-&gt;next; &#125;else &#123; pc-next = pb; pc = pb; pb = pb-&gt;next; &#125; &#125; pc-&gt;next = pa?pa:pb; // pa为空，则等于pb free(Lb);&#125; 循环链表(单向循环链表) 特点：最后一个结点的指针指向头结点 循环链表空表：L-&gt;next == L 判断表为的方法与单链表不同：单链表是p==NULL；循环链表是p==L。 循环链表只设尾指针操作效率会更高。 双向循环链表 特点：每个结点包含后继(next)和前驱(prior)，且两个方向又分别构成循环链表。 双向循环链表判断空表条件(带头节点)：L-&gt;next ==L &amp;&amp;L-&gt;prior==L 与单链表和循环链表区别：最大不同是前驱容易求得，可以向前遍历； 判断表尾方法与循环链表相同：p == L 双向循环链表每个指针都指向前或后一个结点，都不为空。 插入和删除操作 12345678910111213141516171819202122# 在p之后插入s结点s-&gt;next = p-&gt;next;p-&gt;next-&gt;prior = s;s-&gt;prior = p;p-&gt;next = s;# 在p之前插入ss-&gt;prior = p-&gt;prior;p-&gt;prior-&gt;next = s;s-&gt;next = p;p-&gt;prior = s;# 删除p后继ss = p-&gt;next;p-&gt;next = s-&gt;next;s-&gt;next-&gt;prior = s-&gt;prior;free(s);# 删除pp-&gt;prior-&gt;next = p-&gt;next;p-&gt;next-&gt;prior = p-&gt;prior;free(p); 为了方便插入和删除，可以使用双链表存放数据。 顺序表和链表比较 顺序表元素在物理和逻辑上都相邻；链表在逻辑上相邻，物理上不一定。 顺序表随机访问，取元素时O(1)；链表顺序访问，取元素时O(n)。 顺序表插入，删除时需要移动O(n)；单链表插入，删除不用移动元素O(n)(用于查找位置)。 需要反复插入，删除宜采用链表；反复提取，很少插入，删除，宜采用顺序表。 链式存储比顺序存储能更方便的表示各种逻辑结构。 静态链表 需要分配很大的连续空间，插入和删除不需要移动元素。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>线性表</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关闭textarea的拼写检查]]></title>
    <url>%2F2019%2F09%2F06%2Ftextarea%E6%8B%BC%E5%86%99%E6%A3%80%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[最近使用textarea标签发现下面这个问题, 一顿Google最后解决,现在把解决方法做个记录。 解决方法：12&lt;!-- 添加 spellcheck="false" 属性 --&gt;&lt;textarea class="form-control share-text" rows="3" spellcheck="false" &gt;&lt;/textarea&gt;]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>textarea</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git subtree 的使用]]></title>
    <url>%2F2019%2F06%2F12%2Fsubtree%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[git subtree的主要命令有： 123456git subtree add --prefix=&lt;prefix&gt; &lt;commit&gt;git subtree add --prefix=&lt;prefix&gt; &lt;repository&gt; &lt;ref&gt;git subtree pull --prefix=&lt;prefix&gt; &lt;repository&gt; &lt;ref&gt;git subtree push --prefix=&lt;prefix&gt; &lt;repository&gt; &lt;ref&gt;git subtree merge --prefix=&lt;prefix&gt; &lt;commit&gt;git subtree split --prefix=&lt;prefix&gt; [OPTIONS] [&lt;commit&gt;] 准备我们先准备一个仓库叫Photo，一个仓库叫libPNG，然后我们希望把libPNG作为Photo的子仓库。Photo的路径为https://github.com/fanhang64/Photo.git，仓库里的文件有： 1234567Photo | |-- .gitignore |-- Photo.c |-- Photo.h |-- main.c \-- README.rst libPNG的路径为https://github.com/fanhang64/libPNG.git，仓库里的文件有： 1234567libpng | |-- libpng.c |-- libpng.h |-- README.rst |--test.c |--test.h 以下操作均位于父仓库的根目录中。 在父仓库中新增子仓库我们执行以下命令把libpng添加到Photo中： 1git subtree add --prefix=sub/libpng https://github.com/fanhang64/libpng.git master --squash (--squash参数表示不拉取历史信息，而只生成一条commit信息。) 执行git status可以看到提示新增两条commit： git log查看详细修改： 执行git push把修改推送到远端Photo仓库，现在本地仓库与远端仓库的目录结构为： 12345678910111213141516Photo | |-- sub/ | | | \--libpng/ | | | |-- libpng.c | |-- libpng.h | \-- README.rst | |-- test.c | |-- test.h | |-- Photo.c |-- Photo.h |-- main.c \-- README.rst 注意: 现在的Photo仓库对于其他项目人员来说，可以不需要知道libpng是一个子仓库。什么意思呢？当你git clone或者git pull的时候，你拉取到的是整个Photo(包括libpng在内，libpng就相当于Photo里的一个普通目录)；当你修改了libpng里的内容后执行git push，你将会把修改push到Photo上。也就是说Photo仓库下的libpng与其他文件无异。 从源仓库拉取更新如果源libpng仓库更新了，Photo里的libpng如何拉取更新？使用git subtree pull，例如： 1git subtree pull --prefix=sub/libpng https://github.com/fanhang64/libpng.git master --squash 推送修改到源仓库如果在Photo仓库里修改了libpng，然后想把这个修改推送到源libpng仓库呢？使用git subtree push，例如： 1git subtree push --prefix=sub/libpng https://github.com/fanhang64/libPNG.git master 简化git subtree命令我们已经知道了git subtree 的命令的基本用法，但是上述几个命令还是显得有点复杂，特别是子仓库的源仓库地址，特别不方便记忆。这里我们把子仓库的地址作为一个remote，方便记忆： 1git remote add -f libpng https://github.com/fanhang64/libPNG.git 然后可以这样来使用git subtree命令： 123git subtree add --prefix=sub/libpng libpng master --squashgit subtree pull --prefix=sub/libpng libpng master --squashgit subtree push --prefix=sub/libpng libpng master 参考链接： https://segmentfault.com/a/1190000012002151]]></content>
      <categories>
        <category>git相关</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>subtree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言正确使用extern关键字]]></title>
    <url>%2F2019%2F05%2F23%2FC%E8%AF%AD%E8%A8%80%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8extern%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[利用关键字extern，可以在一个文件中引用另一个文件中定义的变量或者函数，下面就结合具体的实例，分类说明一下。 一、引用同一个文件中的变量1234567891011121314151617#include&lt;stdio.h&gt;int func();int main()&#123; func(); printf("%d",num); return 0;&#125;int num = 3;int func()&#123; printf("%d\n",num);&#125; 如果按照这个顺序，变量 num在main函数的后边进行声明和初始化的话，那么在main函数中是不能直接引用num这个变量的，因为当编译器编译到这一句话的时候，找不到num这个变量的声明，但是在func函数中是可以正常使用，因为func对num的调用是发生在num的声明和初始化之后。 问题： 如果我不想改变num的声明的位置，但是想在main函数中直接使用num这个变量，怎么办呢？ 可以使用extern这个关键字。像下面这一段代码，利用extern关键字先声明一下num变量，告诉编译器num这个变量是存在的，但是不是在这之前声明的，你到别的地方找找吧，果然，这样就可以顺利通过编译啦。但是你要是想欺骗编译器也是不行的，比如你声明了extern int num；但是在后面却没有真正的给出num变量的声明，那么编译器去别的地方找了，但是没找到还是不行的。 下面的程序就是利用extern关键字，使用在后边定义的变量。 123456789101112131415161718#include&lt;stdio.h&gt;int func();int main()&#123; func(); // 3 extern int num; printf("%d",num); // 3 return 0;&#125;int num = 3;int func()&#123; printf("%d\n",num);&#125; 二、引用另一个文件中的变量如果extern这个关键字就这点功能，那么这个关键字就显得多余了，因为上边的程序可以通过将num变量在main函数的上边声明，使得在main函数中也可以使用。extern这个关键字的真正的作用是引用不在同一个文件中的变量或者函数。 实例： 12345678910111213141516171819202122// 在main.c中#include&lt;stdio.h&gt;int main()&#123; extern int num; // 引用b.c中的num printf("%d",num); return 0;&#125;// 在b.c文件中#include&lt;stdio.h&gt;int num = 5;void func()&#123; printf("fun in b.c");&#125; 例如，这里b.c中定义了一个变量num，如果main.c中想要引用这个变量，那么可以使用extern这个关键字，注意这里能成功引用的原因是，num这个关键字在b.c中是一个全局变量，也就是说只有当一个变量是一个全局变量时，extern变量才会起作用，向下面这样是不行的。 实例： 1234567891011121314151617181920// 在mian.c中#include&lt;stdio.h&gt;int main()&#123; extern int num; // ok 声明时候不会报错 printf("%d",num); // error return 0;&#125;// 在b.c中#include&lt;stdio.h&gt;void func()&#123; int num = 5; // 局部变量 printf("fun in b.c");&#125; 另外，extern关键字只需要指明类型和变量名就行了，不能再重新赋值，初始化需要在原文件所在处进行，如果不进行初始化的话，全局变量会被编译器自动初始化为0。下面像这种写法是不行的，extern int num=4; ，但是在声明之后就可以使用变量名进行修改了，像这样： 123456789#include&lt;stdio.h&gt;int main()&#123; extern int num; num=1; // ok printf("%d",num); return 0;&#125; 如果不想这个变量被修改可以使用const关键字进行修饰，写法如下： 1234567891011121314151617181920// 在mian.c中#include&lt;stdio.h&gt;int main()&#123; extern const int num; printf("%d",num); return 0;&#125;// 在b.c中#include&lt;stdio.h&gt;const int num=5;void func()&#123; printf("fun in b.c");&#125; 使用include将另一个文件全部包含进去可以引用另一个文件中的变量，但是这样做的结果就是，被包含的文件中的所有的变量和方法都可以被这个文件使用，这样就变得不安全，如果只是希望一个文件使用另一个文件中的某个变量还是使用extern关键字更好（注意：没有include &quot;b.c&quot;文件）。 三、引用另一个文件中的函数extern 关键字除了引用另一个文件中的变量外，还可以引用另一个文件中的函数，引用方法和引用变量相似。 1234567891011121314151617181920// 在mian.c中#include&lt;stdio.h&gt;int main()&#123; extern void func(); func(); return 0;&#125;// 在b.c中#include&lt;stdio.h&gt;const int num=5;void func()&#123; printf("fun in b.c");&#125; 这里main函数中引用了b.c中的函数func。因为所有的函数都是全局的，所以对函数的extern用法和对全局变量的修饰基本相同，需要注意的就是，需要指明返回值的类型和参数。 文章转自网络，查看原文章，请访问：http://blog.csdn.net/xingjiarong/article/details/47656339]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[numpy常用数组操作函数]]></title>
    <url>%2F2019%2F05%2F08%2Fnumpy%E5%B8%B8%E7%94%A8%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0-md%2F</url>
    <content type="text"><![CDATA[Numpy 数组操作函数Numpy 中包含了一些函数用于处理数组，大概可分为以下几类： 修改数组形状 翻转数组 连接数组 分割数组 数组元素的添加与删除 修改数组形状1234567891011121314151617181920# numpy.reshape(shape, order='C') # 参数: order：'C' -- 按行，'F' -- 按列，'A' -- 原顺序，'k' -- 元素在内存中的出现顺序。&gt;&gt; arr = np.arange(12).reshape((3, 4))# ndarray.flatten(order='C')# 返回一份数组拷贝,并返回一维数组# 参数: &gt;&gt; arr.flatten()array([ 1, 3, 5, 4, 6, 8, 7, 9, 11, 10, 12, 14])# numpy.ravel([order])# 展平的数组元素，返回一维数组拷贝,不影响原数组。&gt;&gt; arr.ravel()array([ 1, 3, 5, 4, 6, 8, 7, 9, 11, 10, 12, 14])&gt;&gt; arrarray([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) 翻转数组函数12345678910111213# np.transpose(a, axes=None) # 函数用于对换数组的维度&gt;&gt; arr = np.arange(12).reshape(3, 4)&gt;&gt; print(arr)&gt;&gt; print(np.transpose(arr))&gt;&gt; print(arr.T) # 转置矩阵(同上)[[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]][[ 0 4 8] [ 1 5 9] [ 2 6 10] [ 3 7 11]] 连接数组12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# np.concatenate((a1, a2, ...), axis) # 数用于沿指定轴连接相同形状的两个或多个数组&gt;&gt; arr = np.array([[1, 2], [3, 4]])&gt;&gt; arr2 = np.array([[5 ,6], [7, 8]])&gt;&gt; print(arr, arr2)&gt;&gt; print(np.concatenate((arr, arr2))) # 沿着行连接&gt;&gt; print(np.concatenate((arr, arr2), axis=1) # 沿着列链接[[1 2] [3 4]] [[5 6] [7 8]][[1 2] [3 4] [5 6] [7 8]][[1 2 5 6] [3 4 7 8]] # np.stack(arrays, axis=0) # 函数用于沿指定轴堆积数组序列&gt;&gt; arr = np.array([[1, 2], [3, 4]])&gt;&gt; arr2 = np.array([[5, 6], [7, 8]])&gt;&gt; print(np.stack((arr, arr2))) # 沿着行堆积数组, 二维堆成三维&gt;&gt; print(np.stack((arr, arr2), axis=1)) # 沿着列堆积数组[[[1 2] [3 4]] [[5 6] [7 8]]][[[1 2] [5 6]] [[3 4] [7 8]]]# np.hstack() # 通过水平堆积来生成数组(横向)&gt;&gt; a = np.array((1,2,3))&gt;&gt; b = np.array((2,3,4))&gt;&gt; np.hstack((a,b))array([1, 2, 3, 2, 3, 4])&gt;&gt; a = np.array([ [1], [2], [3]])&gt;&gt; b = np.array([ [2], [3], [4]])&gt;&gt; np.hstack((a,b)) # 水平扩展(a的[1]与b的[2])array([[1, 2], [2, 3], [3, 4]])# np.vstack() # 通过竖直堆积生成数组&gt;&gt; a = np.array([ [1, 2], [3, 4]])&gt;&gt; b = np.array([ [5, 6], [7, 8]])&gt;&gt; print(np.vstack((a, b)))[[1 2] [3 4] [5 6] [7 8]] 分割数组12345678910111213141516171819202122232425262728293031323334353637# np.split(arr, indices_or_sections, axis=0) # 函数沿特定的轴将数组分割为子数组&gt;&gt; a = np.arange(9)&gt;&gt; np.split(a, 1)[array([0, 1, 2, 3, 4, 5, 6, 7, 8])]&gt;&gt; np.split(a, 3) # 将数组分为三个大小相等的子数组[array([0, 1, 2]), array([3, 4, 5]), array([6, 7, 8])]&gt;&gt; np.split(a, [4, 7]) # 将数组在一维数组中表明的位置分割[array([0, 1, 2, 3]), array([4, 5, 6]), array([7, 8])]# np.hsplit(arr, indices_or_sections) 函数用于水平分割数组，通过指定要返回的相同形状的数组数量来拆分原数组。&gt;&gt; x = np.arange(16.0).reshape(4, 4)&gt;&gt; print(x)array([[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.], [12., 13., 14., 15.]])&gt;&gt; np.hsplit(x, 2)[array([[ 0., 1.], [ 4., 5.], [ 8., 9.], [12., 13.]]), array([[ 2., 3.], [ 6., 7.], [10., 11.], [14., 15.]])]&gt;&gt; np.hsplit(x, np.array([1, 2]))[array([[ 0.], [ 4.], [ 8.], [12.]]), array([[ 1.], [ 5.], [ 9.], [13.]]), array([[ 2., 3.], [ 6., 7.], [10., 11.], [14., 15.]])] 参考文档:https://www.runoob.com/numpy/numpy-array-manipulation.html]]></content>
      <categories>
        <category>数据分析与机器学习</category>
      </categories>
      <tags>
        <tag>数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo添加访问量统计]]></title>
    <url>%2F2019%2F05%2F07%2Fhexo%E6%B7%BB%E5%8A%A0%E8%AE%BF%E9%97%AE%E9%87%8F%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[使用的是不蒜子提供的阅读统计功能，hexo主题是next。 步骤如下:1) 添加是否开启统计功能的配置 找到next主题的配置文件themes/next/_config.yml，找到原来的footer字段，加入一个配置，这里我们叫它counter吧，即12footer: counter: true 注意:hexo博客解决不蒜子统计无法显示问题, 这里引用官网 因七牛强制过期『dn-lbstatics.qbox.me』域名，与客服沟通无果，只能更换域名到『busuanzi.ibruce.info』！ 2) 修改next主题的模板文件由于是把访问量统计放在网页的footer，所以我们需要修改的模板文件是theme/next/layout/_partials/footer.swig。我们在合适的位置加入：123456789&#123;% if theme.footer.counter %&#125; &lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; &lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt; &lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;总访客&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人&lt;/span&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&#123;% endif %&#125;]]></content>
      <categories>
        <category>hexo的使用</category>
      </categories>
      <tags>
        <tag>hexo的使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[numpy的基本使用]]></title>
    <url>%2F2019%2F05%2F05%2Fnumpy%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[NumPy的基本使用Numpy是一个开源的Python科学计算库，它是Python进行科学计算的基础库，许多著名的科学计算库如Pandas，Scikit-learn等都要用到Numpy库的一些功能。NumPy根据BSD许可证授权，只需很少的限制即可重复使用。 基础知识NumPy是一个元素表(通常是数字), 这些元素都具有相同的类型，由正整数元组索引的多维数组。在NumPy维度中称为轴。 例如: 在一个3D空间中[1, 2, 1] 有一个轴, 这个轴里面有三个元素, 因此它的长度就是3。如下所示, 这个数组有2个轴, 第一个轴长度为2 即[1., 0., 0.]和[0., 1., 2.] , 第二个轴长度为3(三个元素)。 12[[ 1., 0., 0.], [ 0., 1., 2.]] NumPy的类型称为ndarray, 即数组。请注意，numpy.array与标准Python库类array.array不同。如下是常用属性: ndarray.ndim : 数组轴的个数(维度)。 ndarray.shape : 数组的维度, 返回一个整数的元组, 表示这个维度数组的大小, 对于一个n行和m列的矩阵，shape将为（n，m）。注意，shape这个元组的长度是轴的数量即ndim。 ndarray.size : 数组所有元素的个数。 ndarray.dtype : 描述数组元素类型。 ndarray.itemsize : 数组中每个元素的字节大小。 ndarray.T : 数组的转置。 ndarray.real : 输出数组包含元素的实部。 ndarray.imag : 输出数组包含元素的虚部分。 Example: 1234567891011121314151617181920212223242526272829import numpy as np# np.arange([start,] stop[, step,], dtype=None)arr = np.arange(3)print(arr)# array([0, 1, 2])arr = np.arange(3.0) # 与python标准库函数range不同, arange可以传float类型参数print(arr)# array([0., 1., 2.])arr = np.arange(3, 7)print(arr)# array([3, 4, 5, 6])arr = np.arange(15).reshape(3, 5)# array([[ 0, 1, 2, 3, 4],# [ 5, 6, 7, 8, 9],# [10, 11, 12, 13, 14]])print(arr.shape) # (3, 5)print(arr.ndim) # 2print(arr.dtype.name) # int64print(arr.itemsize) # 8print(arr.size) # 15print(type(arr)) # &lt;type 'numpy.ndarray'&gt;arr = np.array([1,2, 3])print(type(arr)) # &lt;type 'numpy.ndarray'&gt; 创建数组1) 通过列表或元组创建 最终数组的类型取决于序列中元素的类型 1234567891011121314import numpy as nparr = np.array([2, 3, 4])print(arr) # array([2, 3, 4])print(arr.dtype) # dtype('int64')arr = np.array([1.2, 2.3, 3.4])print(arr.dtype) # dtype('float64')# 二维数组 (2*3)arr2 = np.array([[1,2,4], [3,4,5]])print(arr2)# array([[1, 2, 4],# [3, 4, 5]]) 2) 通过np.arrange()等方法创建 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import numpy as nparr = np.arange(10, 30, 5)print(arr) # array([10, 15, 20, 25])arr = np.zeros((3,4))print(arr) # 创建一个全为0的数组# array([[ 0., 0., 0., 0.],# [ 0., 0., 0., 0.],# [ 0., 0., 0., 0.]])arr = np.ones((2, 3, 4), dtype=np.int16) # 可以指定参数print(arr) # 创建一个全为1的数组# array([[[ 1, 1, 1, 1],# [ 1, 1, 1, 1],# [ 1, 1, 1, 1]],# [[ 1, 1, 1, 1],# [ 1, 1, 1, 1],# [ 1, 1, 1, 1]]], dtype=int16)# linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None) # 返回在start到stop之间均匀分布的num个数字，可以选择是否包括stop. retstep表示是否返回步长.arr = np.linspace(1, 5, 5, True)print(arr) # array([ 1., 2., 3., 4., 5.])arr = np.linspace(1, 5, 5, False)print(arr) # array([ 1. , 1.8, 2.6, 3.4, 4.2])# numpy.eye(N, M=None, k=0, dtype=&lt;class 'float'&gt;, order='C')# 返回一个二维数组，其中对角线为1，其他位置为零。k：对角线的索引：0（默认值）是主对角线，正值指的是上对角线，负值指的是下对角线。arr = np.eye(2, dtype=int)print(arr)# array([[1, 0],# [0, 1]])arr = np.eye(3, k=1)print(arr)# array([[0., 1., 0.],# [0., 0., 1.],# [0., 0., 0.]])# ones_like，zeros_like，empty_like函数# 返回一个与给定数组具有相同形状和类型的数组。x = np.arange(6)x = x.reshape((2, 3))print(x)# array([[0, 1, 2],# [3, 4, 5]])arr = np.ones_like(x) # zeros_like，empty_like雷同print(arr)# array([[1, 1, 1],# [1, 1, 1]]) 基本操作Example: 1234567891011121314151617181920212223242526272829303132333435363738394041import numpy as npa = np.array([20, 30, 40, 50])b = np.arange(4)print(b) # array([0, 1, 2, 3])c = a - bprint(c) # array([20, 29, 38, 47])d = b ** 2 print(d) # array([0, 1, 4, 9])e = 10 * np.sin(a)print(e) # array([ 9.12945251, -9.88031624, 7.4511316 , -2.62374854])f = a &lt; 35print(f) # array([ True, True, False, False])# 矩阵(数组)*点乘和@叉乘A = np.array([[1,1], [0,1]])B = np.array([[2,0], [3,4]])print(A * B)# array([[2, 0],# [0, 4]])print(A @ B) # 同 A.dot(B)# array([[5, 4],# [3, 4]])# 重设形状# np.reshape(shape, order='C')print(np.arange(6).reshape((3, 2)))# [[0 1]# [2 3]# [4 5]]# 数组展开# np.ravel([order]) # order 表示变换时的读取顺序，默认是Order='C' 按照行依次读取，当 order='F' 时，可以按列依次读取arr = np.arange(6).reshape((3, 2))print(arr.ravel()) # array([0, 1, 2, 3, 4, 5])print(arr.ravel('F') # array([0, 2, 4, 1, 3, 5]) 注意: 大小相等的数组之间的任何算术运算都会将运算应用到元素级 数组与标量的算术运算会将标量值传播到各个元素 索引, 切片, 迭代(1) 一维数组操作一维数组可以进行索引，切片和迭代操作，就像列表和其他Python序列一样。 Example: 1234567891011import numpy as npa = np.arange(10) ** 3print(a) # array([ 0, 1, 8, 27, 64, 125, 216, 343, 512, 729])print(a[2:5]) # array([8, 27, 64])a[:6:2] = 1000 # 等同于a[0:6:2] = -1000 即 0 2 4 置为0a[::-1] # array([729, 512, 343, 216, 125, -1000, 27, -1000, 1, -1000])for i in a: print(i) # 0 1 ... (2) 多维数组操作Example: 123456789101112131415161718192021222324252627&gt;&gt; def f(x, y):... return 10 * x + y&gt;&gt; arr = np.fromfunction(f, (5, 4), dtype=int)&gt;&gt; print(arr)array([[ 0, 1, 2, 3], [10, 11, 12, 13], [20, 21, 22, 23], [30, 31, 32, 33], [40, 41, 42, 43]])&gt;&gt; b[1, 3] # b[行索引, 列索引]13&gt;&gt; b[0:5, 1] # 每一行的第1列array([ 1, 11, 21, 31, 41])&gt;&gt; b[1:3, :] # 第1-2行的所有列array([[10, 11, 12, 13], [20, 21, 22, 23]])&gt;&gt; c = np.arange(12)&gt;&gt; print(c)[ 0 1 2 3 4 5 6 7 8 9 10 11]&gt;&gt; print(c[4]) # 4&gt;&gt; c.shape = (3, 4) # c变为2维数组&gt;&gt; print(c)[[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] 当提供的索引数少于轴数时，缺失的索引将被视为完整切片： 12&gt;&gt; b[-1] # 取最后一行,等同于b[-1,:]array([40, 41, 42, 43]) 针对第一个轴对多维数组进行迭代： 1234567891011121314151617&gt;&gt; for i in b:... print(i)[0 1 2 3][10 11 12 13][20 21 22 23][30 31 32 33][40 41 42 43]# 可以通过np.flat遍历每一个元素, flat属性返回一个迭代器, &gt;&gt;&gt; for i in b.flat:... print(i)012310... (3) 整数数组索引1234567891011121314151617181920212223242526272829303132333435363738394041424344&gt;&gt; import numpy as np&gt;&gt; arr = np.arange(1,10)&gt;&gt; print(arr)[1 2 3 4 5 6 7 8 9]&gt;&gt; arr[np.array([2, 2, -3, 7])] # 由值2，2，-3和7组成的索引数组相应地创建了一个长度为4的数组。array([3, 3, 7, 8])&gt;&gt; arr = np.arange(6).reshape((3, 2))&gt;&gt; print(arr)[[0 1] [2 3] [4 5]]&gt;&gt; arr2 = arr[[0,1]] # 获取0,1行的值&gt;&gt; print(arr2)[[0 1] [2 3]]# 下面这种情况，如果索引数组具有匹配的形状，并且索引数组的每个维都有一个索引数组，则结果数组具有与索引数组相同的形状，并且这些值对应于每个索引集的索引在索引数组中的位置。在此示例中，两个索引数组的第一个索引值为0，因此结果数组的第一个值为arr3[0,0]。下一个值是arr3[1,1]，最后一个是arr3[2,3]&gt;&gt; arr3 = np.arange(12).reshape(3, 4)&gt;&gt; print(arr3)[[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]]&gt;&gt; arr3[[0,1,2], [0, 1, 3]][0 5 11]&gt;&gt; arr4 = arr3[[0,1,2], [1]] # 获取0,1行第1列的值, 尝试将它们广播到相同的形状，即取值arr3[0,1]，arr3[1, 1], arr3[2, 1]&gt;&gt; print(arr4)[1, 5, 9]&gt;&gt; arr = np.arange(12).reshape((4, 3))[[ 0 1 2] [ 3 4 5] [ 6 7 8] [ 9 10 11]]&gt;&gt; rows = np.array([[0,0], [3,3]])&gt;&gt; cols = np.array([[0,2], [0,2]])&gt;&gt; x = arr[rows, cols] # 取四个角元素&gt;&gt; print(x)[[ 0 2] [ 9 11]] (4) 布尔索引布尔数组的形状必须与被索引数组的初始维度相同，其中包含索引数组中所有对应于布尔数组中所有真实元素的元素。 Example: 123456789101112131415161718&gt;&gt; import numpy as np&gt;&gt; arr = np.arange(12).reshape(3, 4)&gt;&gt; print(arr)&gt;&gt; x = arr &gt; 7&gt;&gt; print(x)[[False False False False] [False False False False] [ True True True True]]&gt;&gt; arr[x] # 结果为一维数组array([ 8, 9, 10, 11])&gt;&gt; y = x[:, 1]&gt;&gt; print(y) # 所有行的第一列元素(广播)[False False True]&gt;&gt; arr[y] # 即取第2行, 0,1行为False不取array([[ 8, 9, 10, 11]]) 广播广播(Broadcast)是 numpy 对不同shape的数组进行数值计算的方式，对数组的算术运算通常是元素级别的。 如果两个数组 a 和 b 形状相同，即满足a.shape == b.shape，那么 a*b 的结果就是 a 与 b 数组对应位置的元素相乘。这要求维数相同，且各维度的长度相同。 123456import numpy as nparr1 = np.array([1, 2, 3])arr2 = np.arange(11, 14)arr = arr1 + arr2print(arr) # [12 14 16] 当执行操作的两个数组, shape不同时,会自动触发广播机制。 1234567891011&gt;&gt; import numpy as np&gt;&gt; arr2 = np.array([1, 2, 3])&gt;&gt; arr3 = np.arange(12).reshape((4, 3))&gt;&gt; arr = arr2 + arr3 # ==&gt; 等同于 arr2为[[1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3]]相加&gt;&gt; print(arr)[[ 1 3 5] [ 4 6 8] [ 7 9 11] [10 12 14]] 参考文档： https://www.numpy.org/devdocs/user/quickstart.html https://www.numpy.org.cn/user_guide/numpy_basics/indexing.html https://www.runoob.com/numpy/numpy-broadcast.html]]></content>
      <categories>
        <category>数据分析与机器学习</category>
      </categories>
      <tags>
        <tag>数据</tag>
      </tags>
  </entry>
</search>
